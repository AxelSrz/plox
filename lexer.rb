#--
# DO NOT MODIFY!!!!
# This file is automatically generated by rex 1.0.5
# from lexical definition file "objective_plox_lex.rex".
#++

require 'racc/parser'
require_relative 'parser'

class ObjectivePlox < Racc::Parser
  require 'strscan'

  class ScanError < StandardError ; end

  attr_reader   :lineno
  attr_reader   :filename
  attr_accessor :state

  def scan_setup(str)
    @ss = StringScanner.new(str)
    @lineno =  1
    @state  = nil
  end

  def action
    yield
  end

  def scan_str(str)
    scan_setup(str)
    do_parse
  end
  alias :scan :scan_str

  def load_file( filename )
    @filename = filename
    open(filename, "r") do |f|
      scan_setup(f.read)
    end
  end

  def scan_file( filename )
    load_file(filename)
    do_parse
  end


  def next_token
    return if @ss.eos?
    
    # skips empty actions
    until token = _next_token or @ss.eos?; end
    token
  end

  def _next_token
    text = @ss.peek(1)
    @lineno  +=  1  if text == "\n"
    token = case @state
    when nil
      case
      when (text = @ss.scan(/[ \t\n\r\f]/))
        ;

      when (text = @ss.scan(/[a-zA-Z][a-zA-Z0-9]*/))
         action { $line_number = lineno; if text == "habemvs" then return [:HABEMVS, text]
                           elsif text == "oblivion" then return [:OBLIVION, text]
                           elsif text == "var" then return [:VAR, text]
                           elsif text == "eternal" then return [:ETERNAL, text]
                           elsif text == "chief" then return [:CHIEF, text]
                           elsif text == "open" then return [:OPEN, text]
                           elsif text == "hidden" then return [:HIDDEN, text]
                           elsif text == "species" then return [:SPECIES, text]
                           elsif text == "fresh" then return [:FRESH, text]
                           elsif text == "null" then return [:NULL, text]
                           elsif text == "if" then return [:IF, text]
                           elsif text == "else" then return [:ELSE, text]
                           elsif text == "while" then return [:WHILE, text]
                           elsif text == "do" then return [:DO, text]
                           elsif text == "unless" then return [:UNLESS, text]
                           elsif text == "true" then return [:TRUE, text]
                           elsif text == "false" then return [:FALSE, text]
                           elsif text == "var" then return [:VAR, text]
                           elsif text == "say" then return [:SAY, text]
                           elsif text == "hear" then return [:HEAR, text]
                           elsif text == "itself" then return [:ITSELF, text]
                           elsif text == "funk" then return [:FUNK, text]
                           elsif text == "eternal" then return [:ETERNAL, text]
                           elsif text == "heirof" then return [:HEIROF, text]
                           elsif text == "reply" then return [:REPLY, text]
                           elsif text == "number" then return [:NUMBER, text]
                           elsif text == "decimal" then return [:DECIMAL, text]
                           elsif text == "char" then return [:CHAR, text]
                           elsif text == "string" then return [:STRING, text]
                           elsif text == "logic" then return [:LOGIC, text]
                           else return [:ID, text] end }


      when (text = @ss.scan(/[0-9]+\.[0-9]+/))
         action { [:CTED, text.to_f] }

      when (text = @ss.scan(/[0-9]+/))
         action { [:CTEN, text.to_i] }

      when (text = @ss.scan(/".*"/))
         action { [:CTESTRING, text] }

      when (text = @ss.scan(/!=/))
         action { [:DIFFERENT, text] }

      when (text = @ss.scan(/\|\|=/))
         action { [:ORASSIGN, text] }

      when (text = @ss.scan(/&&=/))
         action { [:ANDASSIGN, text] }

      when (text = @ss.scan(/\+=/))
         action { [:PLUSASSIGN, text] }

      when (text = @ss.scan(/\-=/))
         action { [:MINUSASSIGN, text] }

      when (text = @ss.scan(/\*=/))
         action { [:MULTASSIGN, text] }

      when (text = @ss.scan(/\/=/))
         action { [:DIVASSIGN, text] }

      when (text = @ss.scan(/%=/))
         action { [:MODASSIGN, text] }

      when (text = @ss.scan(/==/))
         action { [:EQUALITY, text] }

      when (text = @ss.scan(/\<=/))
         action { [:LEQUAL, text] }

      when (text = @ss.scan(/\>=/))
         action { [:MEQUAL, text] }

      when (text = @ss.scan(/&&/))
         action { [:AND, text] }

      when (text = @ss.scan(/\|\|/))
         action { [:OR, text] }

      when (text = @ss.scan(/!/))
         action { [:NOT, text] }

      when (text = @ss.scan(/%/))
         action { [:MOD, text] }

      when (text = @ss.scan(/\*/))
         action { [:MULT, text]}

      when (text = @ss.scan(/\//))
         action { [:DIV, text]}

      when (text = @ss.scan(/\+/))
         action { [:PLUS, text]}

      when (text = @ss.scan(/\-/))
         action { [:MINUS, text] }

      when (text = @ss.scan(/\(/))
         action { [:PLEFT, text] }

      when (text = @ss.scan(/\)/))
         action { [:PRIGHT, text] }

      when (text = @ss.scan(/\{/))
         action { [:BLEFT, text] }

      when (text = @ss.scan(/\}/))
         action { [:BRIGHT, text] }

      when (text = @ss.scan(/\[/))
         action { [:SBLEFT, text] }

      when (text = @ss.scan(/\]/))
         action { [:SBRIGHT, text] }

      when (text = @ss.scan(/:/))
         action { [:TWOP, text] }

      when (text = @ss.scan(/;/))
         action { [:SEMIC, text] }

      when (text = @ss.scan(/=/))
         action { [:EQUAL, text] }

      when (text = @ss.scan(/,/))
         action { [:COMA, text] }

      when (text = @ss.scan(/\./))
         action { [:POINT, text] }

      when (text = @ss.scan(/\</))
         action { [:LTHAN, text] }

      when (text = @ss.scan(/\>/))
         action { [:MTHAN, text] }

      else
        text = @ss.string[@ss.pos .. -1]
        raise  ScanError, "can not match: '" + text + "'"
      end  # if

    else
      raise  ScanError, "undefined state: '" + state.to_s + "'"
    end  # case state
    token
  end  # def _next_token

  def tokenize(code)
    scan_setup(code)
    tokens = []
    while token = next_token
      tokens << token
    end
    tokens
  end
end # class
