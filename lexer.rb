#--
# DO NOT MODIFY!!!!
# This file is automatically generated by rex 1.0.5
# from lexical definition file "objective_plox_lex.rex".
#++

require 'racc/parser'
require_relative 'parser'

class ObjectivePlox < Racc::Parser
  require 'strscan'

  class ScanError < StandardError ; end

  attr_reader   :lineno
  attr_reader   :filename
  attr_accessor :state

  def scan_setup(str)
    @ss = StringScanner.new(str)
    @lineno =  1
    @state  = nil
  end

  def action
    yield
  end

  def scan_str(str)
    scan_setup(str)
    do_parse
  end
  alias :scan :scan_str

  def load_file( filename )
    @filename = filename
    open(filename, "r") do |f|
      scan_setup(f.read)
    end
  end

  def scan_file( filename )
    load_file(filename)
    do_parse
  end


  def next_token
    return if @ss.eos?
    
    # skips empty actions
    until token = _next_token or @ss.eos?; end
    token
  end

  def _next_token
    text = @ss.peek(1)
    @lineno  +=  1  if text == "\n"
    token = case @state
    when nil
      case
      when (text = @ss.scan(/[ \t\n\r\f]/))
        ;

      when (text = @ss.scan(/[a-zA-Z][a-zA-Z0-9]*/))
         action { $line_number = lineno; if text == "habemvs" then return [:HABEMVS, text]
                           elsif text == "oblivion" then return [:OBLIVION, {0 => text}]
                           elsif text == "var" then return [:VAR, {0 => text}]
                           elsif text == "eternal" then return [:ETERNAL, {0 => text}]
                           elsif text == "chief" then return [:CHIEF, {0 => text}]
                           elsif text == "open" then return [:OPEN, {0 => text}]
                           elsif text == "hidden" then return [:HIDDEN, {0 => text}]
                           elsif text == "species" then return [:SPECIES, {0 => text}]
                           elsif text == "null" then return [:NULL, {0 => text}]
                           elsif text == "if" then return [:IF, {0 => text}]
                           elsif text == "else" then return [:ELSE, {0 => text}]
                           elsif text == "elsif" then return [:ELSIF, {0 => text}]
                           elsif text == "while" then return [:WHILE, {0 => text}]
                           elsif text == "do" then return [:DO, {0 => text}]
                           elsif text == "unless" then return [:UNLESS, {0 => text}]
                           elsif text == "true" then return [:TRUE, {0 => "logic", 1 => true}]
                           elsif text == "false" then return [:FALSE, {0 => "logic", 1 => false}]
                           elsif text == "var" then return [:VAR, {0 => text}]
                           elsif text == "say" then return [:SAY, {0 => text}]
                           elsif text == "hear" then return [:HEAR, {0 => text}]
                           elsif text == "itself" then return [:ITSELF, {0 => text}]
                           elsif text == "funk" then return [:FUNK, {0 => text}]
                           elsif text == "eternal" then return [:ETERNAL, {0 => text}]
                           elsif text == "heirof" then return [:HEIROF, {0 => text}]
                           elsif text == "reply" then return [:REPLY, {0 => text}]
                           elsif text == "number" then return [:NUMBER, {0 => text}]
                           elsif text == "decimal" then return [:DECIMAL, {0 => text}]
                           elsif text == "char" then return [:CHAR, {0 => text}]
                           elsif text == "string" then return [:STRING, {0 => text}]
                           elsif text == "logic" then return [:LOGIC, {0 => text}]
                           else return [:ID, {0 => text}] end }


      when (text = @ss.scan(/[0-9]+\.[0-9]+/))
         action { [:CTED, {0 => "decimal", 1 => text.to_f}] }

      when (text = @ss.scan(/[0-9]+/))
         action { [:CTEN, {0 => "number", 1 => text.to_i}] }

      when (text = @ss.scan(/".*"/))
         action { [:CTESTRING, {0 => "string", 1 => text[1...-1]}] }

      when (text = @ss.scan(/!=/))
         action { [:DIFFERENT, {0 => text}] }

      when (text = @ss.scan(/\|\|=/))
         action { [:ORASSIGN, {0 => text}] }

      when (text = @ss.scan(/&&=/))
         action { [:ANDASSIGN, {0 => text}] }

      when (text = @ss.scan(/\+=/))
         action { [:PLUSASSIGN, {0 => text}] }

      when (text = @ss.scan(/\-=/))
         action { [:MINUSASSIGN, {0 => text}] }

      when (text = @ss.scan(/\*=/))
         action { [:MULTASSIGN, {0 => text}] }

      when (text = @ss.scan(/\/=/))
         action { [:DIVASSIGN, {0 => text}] }

      when (text = @ss.scan(/%=/))
         action { [:MODASSIGN, {0 => text}] }

      when (text = @ss.scan(/==/))
         action { [:EQUALITY, {0 => text}] }

      when (text = @ss.scan(/\<=/))
         action { [:LEQUAL, {0 => text}] }

      when (text = @ss.scan(/\>=/))
         action { [:MEQUAL, {0 => text}] }

      when (text = @ss.scan(/&&/))
         action { [:AND, {0 => text}] }

      when (text = @ss.scan(/\|\|/))
         action { [:OR, {0 => text}] }

      when (text = @ss.scan(/!/))
         action { [:NOT, {0 => text}] }

      when (text = @ss.scan(/%/))
         action { [:MOD, {0 => text}] }

      when (text = @ss.scan(/\*/))
         action { [:MULT, {0 => text}]}

      when (text = @ss.scan(/\//))
         action { [:DIV, {0 => text}]}

      when (text = @ss.scan(/\+/))
         action { [:PLUS, {0 => text}]}

      when (text = @ss.scan(/\-/))
         action { [:MINUS, {0 => text}] }

      when (text = @ss.scan(/\(/))
         action { [:PLEFT, {0 => text}] }

      when (text = @ss.scan(/\)/))
         action { [:PRIGHT, {0 => text}] }

      when (text = @ss.scan(/\{/))
         action { [:BLEFT, {0 => text}] }

      when (text = @ss.scan(/\}/))
         action { [:BRIGHT, {0 => text}] }

      when (text = @ss.scan(/\[/))
         action { [:SBLEFT, {0 => text}] }

      when (text = @ss.scan(/\]/))
         action { [:SBRIGHT, {0 => text}] }

      when (text = @ss.scan(/:/))
         action { [:TWOP, {0 => text}] }

      when (text = @ss.scan(/;/))
         action { [:SEMIC, {0 => text}] }

      when (text = @ss.scan(/=/))
         action { [:EQUAL, {0 => text}] }

      when (text = @ss.scan(/,/))
         action { [:COMA, {0 => text}] }

      when (text = @ss.scan(/\./))
         action { [:POINT, {0 => text}] }

      when (text = @ss.scan(/\</))
         action { [:LTHAN, {0 => text}] }

      when (text = @ss.scan(/\>/))
         action { [:MTHAN, {0 => text}] }

      else
        text = @ss.string[@ss.pos .. -1]
        raise  ScanError, "can not match: '" + text + "'"
      end  # if

    else
      raise  ScanError, "undefined state: '" + state.to_s + "'"
    end  # case state
    token
  end  # def _next_token

  def tokenize(code)
    scan_setup(code)
    tokens = []
    while token = next_token
      tokens << token
    end
    tokens
  end
end # class
